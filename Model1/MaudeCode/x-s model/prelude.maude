--- ----------------------------------
--- Prelude of the X-S Model
--- ----------------------------------

load sampler .

fmod ARGUMENT is
--- Arguments consist of a pair <id,b> where:
--- *id is a natural number to identify the argument
--- *b can be 1 if it is a pro argument, or -1 if it is a con argument
	sort Argument .
	pr INT .
	pr NAT .

	op [_,_] : Nat Int -> Argument [ctor] . 

endfm

--- Definition of view, to be able to construct sets of arguments
view Argument from TRIV to ARGUMENT is
  sort Elt to Argument .
endv 

mod ARGUMENTPOOL is
--- Used to define the set of all the arguments 
	pr SAMPLER .
	pr ARGUMENT .
	pr SET{Argument} * (sort Set{Argument} to ArgumentSet, sort NeSet{Argument} to NeArgumentSet) .
	sort ArgumentPool .

--- The argument pool consists of two ArgumentSets
--- The first one is the pro arguments and the second one is con arguments
	op {_|_} : ArgumentSet ArgumentSet -> ArgumentPool [ctor] .

--- Equations
	vars a b : Nat .

	--- initialize an ArgumentSet with a pro arguments
	op initProArgumentSet : Nat -> ArgumentSet .
	eq initProArgumentSet(s(a)) = [s(a), 1] , initProArgumentSet(a) .
	eq initProArgumentSet(0) = (empty).ArgumentSet .

		--- initialize an ArgumentSet with a con arguments
	op initConArgumentSet : Nat -> ArgumentSet .
	eq initConArgumentSet(s(a)) = [s(a), -1] , initConArgumentSet(a) .
	eq initConArgumentSet(0) = (empty).ArgumentSet .

	--- initialize an Argument pool with a pro arguments and b pro arguments
	op initArgumentPool : Nat Nat -> ArgumentPool .
	eq initArgumentPool(a,b) = { (initProArgumentSet(a)) | (initConArgumentSet(b)) } .

	--- randomly pick an Argument from an ArgumentSet
	op randomPick : ArgumentSet -> Argument .

endm

mod AGENTS is
--- Agents are represented as a tuple ag(id,g,o,S) where
--- * id is a natural number to identify the agent
--- * g is the group identity {-1,+1}
--- * o is the opinion [-1,1]
--- * S is the memory vector or argument vector, represented as a list of arguments
--- * Memory is like a queue with fixed size, where the last argument that enters the memory is the most relevant
	pr ARGUMENT .
	pr ARGUMENTPOOL .
	pr FLOAT .
	pr SAMPLER .
	pr LIST{Int} * (sort List{Int} to Memory, sort NeList{Int} to NeMemory) .

	sort Agent .
	op ag : Nat Int Float Memory -> Agent [ctor] .

--- Equations:
	vars id a : Nat .
	vars g i : Int .
	vars o p w : Float .
	vars S S' : Memory .  
	
	--- get number of pro arguments
	op getPosArg : Agent -> Nat .
	op getPosArg2 : Int Memory -> Nat . 
	eq getPosArg(ag(id,g,o,S)) = getPosArg2(g,S) .
	eq getPosArg2(g, i S') = if g == i 
							 then 1 + getPosArg2(g,S')
							 else getPosArg2(g,S')
							 fi .
	eq getPosArg2(g, nil) = 0 . 

	--- calculate opinion
	op computeOpinion : Agent -> Float .
	op computeOpinion2 : Int Memory -> Float .
	eq computeOpinion(ag(id,g,o,S)) = computeOpinion2(g, S) .
	eq computeOpinion2(g, S) = 2.0 * ( float(getPosArg2(g,S)) / float(size(S)) ) - 1.0 .


	--- with probability p, choose probabilistically a pro argument or con argument
	op chooseArgument : Float -> Int .
	eq chooseArgument(p) = if sampleBerWithP(p) then 1 else -1 fi .

	--- initialize list of memories using the size of the memory and the pro argument probability p
	op initMemory : Nat Float -> Memory .
	eq initMemory(0,p) = nil .
	eq initMemory(s(a),p) = chooseArgument(p) initMemory(a,p) .

	--- initialize an Agent using: 
	---   - The id of the agent (id)
	---   - The group it belongs to (g)
	---   -	The size of the memory (a) 
	---   - The pro argument probability (w)
	op initAgent : Nat Int Nat Float -> Agent .
	op initAgent2 : Nat Int Memory -> Agent .
	eq initAgent(id, g, a, w) = initAgent2(id, g, initMemory(a,w)) .
	eq initAgent2(id, g, S) = ag(id, g, computeOpinion2(g, S), S) .

endm

--- Definition of view, to be able to construct sets of agents
view Agent from TRIV to AGENTS is
  sort Elt to Agent .
endv

mod NETWORK is 
	pr AGENTS .
	pr SET{Agent} * (sort Set{Agent} to Network, sort NeSet{Agent} to NeNetwork) .


	--- initialize a network. The parameters are:
	---   - The size of the network (N)
	---   - The pro argument probability (w)
	---   -	The size of the memory (a)
	--- Half of the network will belong to group +1 and the other half to group -1
	vars N n a mid : Nat .
	vars w : Float .
	
	op initNetwork : Nat Nat Float -> Network .
	op initNetwork2 : Nat Nat Float Nat -> Network .
	eq initNetwork(N,a,w) = initNetwork2(N, a, w, N quo 2) .
	eq initNetwork2(s(n),a,w,mid) = if s(n) <= mid 
									then initAgent(s(n),1,a,w) , initNetwork2(n,a,w,mid)
									else initAgent(s(n),-1,a,w) , initNetwork2(n,a,w,mid)
									fi .
	eq initNetwork2(0,a,w,mid) = (empty).Network .		
	
endm 

--- testing
--- Agent examples
--- ag(1,-1,0.4,(1 1 1 1 1 1 1 1))