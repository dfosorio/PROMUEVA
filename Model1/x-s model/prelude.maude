--- ----------------------------------
--- Prelude of the X-S Model
--- ----------------------------------

load sampler .

fmod ARGUMENT is
--- Arguments consist of a pair [id,b] where:
--- *id is a natural number to identify the argument
--- *b can be 1 if it is a pro argument, or -1 if it is a con argument
	sort Argument .
	pr INT .
	pr NAT .

	op [_,_] : Nat Int -> Argument [ctor] . 

endfm

--- Definition of view, to be able to construct sets and lists of arguments
view Argument from TRIV to ARGUMENT is
  sort Elt to Argument .
endv 

mod ARGUMENTPOOL is
--- Used to define the set of all the arguments 
	pr SAMPLER .
	pr ARGUMENT .
	pr SET{Argument} * (sort Set{Argument} to ArgumentSet, sort NeSet{Argument} to NeArgumentSet) .
	sort ArgumentPool .

--- The argument pool consists of two ArgumentSets
--- The first one are the pro arguments and the second one are the con arguments
	op {_|_} : ArgumentSet ArgumentSet -> ArgumentPool [ctor] .

--- Equations
	vars a b : Nat .
	vars A : Argument .
	vars S : ArgumentSet .

	--- initialize an ArgumentSet with a pro arguments
	op initProArgumentSet : Nat -> ArgumentSet .
	eq initProArgumentSet(s(a)) = [s(a), 1] , initProArgumentSet(a) .
	eq initProArgumentSet(0) = (empty).ArgumentSet .

	--- initialize an ArgumentSet with a con arguments
	op initConArgumentSet : Nat -> ArgumentSet .
	eq initConArgumentSet(s(a)) = [s(a), -1] , initConArgumentSet(a) .
	eq initConArgumentSet(0) = (empty).ArgumentSet .

	--- initialize an Argument pool with a pro arguments and b pro arguments
	op initArgumentPool : Nat Nat -> ArgumentPool .
	eq initArgumentPool(a,b) = { (initProArgumentSet(a)) | (initConArgumentSet(b)) } .

	--- select the nth argument of an argument set
	op selectElement : ArgumentSet Nat -> Argument .
	eq selectElement((A,S), 0) = A .
	eq selectElement((A,S), s(a)) = selectElement(S, a) .

	--- Randomly select an argument of an argument set
	op randomPick : ArgumentSet -> Argument .
	eq randomPick(S) = selectElement(S, genRandom(0,| S | - 1)) .

endm

mod AGENTS is
--- Agents are represented as a tuple ag(id,g,o,S) where
--- * id is a natural number to identify the agent
--- * g is the group identity {-1,+1}
--- * o is the opinion [-1,1]
--- * S is the memory vector or argument vector, represented as a list of arguments
--- * Memory is like a queue with fixed size, where the last argument that enters the memory is the most relevant
	pr ARGUMENT .
	pr ARGUMENTPOOL .
	pr FLOAT .
	pr SAMPLER .
	pr LIST{Argument} * (sort List{Argument} to Memory, sort NeList{Argument} to NeMemory) .

	sort Agent .
	op ag : Nat Int Float Memory -> Agent [ctor] .

--- Equations:
	vars id a : Nat .
	vars g i : Int .
	vars o p w : Float .
	vars S : Memory .
	vars A : Argument .
	vars AP : ArgumentPool .
	vars PRO CON : ArgumentSet .  
	
	--- get number of positive arguments for the agent in group g
	op getPosArg : Agent -> Nat .
	op getPosArg2 : Int Memory -> Nat . 
	eq getPosArg(ag(id,g,o,S)) = getPosArg2(g,S) .
	eq getPosArg2(g, [a,i] S) = if g == i 
							 then 1 + getPosArg2(g,S)
							 else getPosArg2(g,S)
							 fi .
	eq getPosArg2(g, nil) = 0 . 

	--- calculate opinion
	op computeOpinion : Agent -> Float .
	op computeOpinion2 : Int Memory -> Float .
	eq computeOpinion(ag(id,g,o,S)) = computeOpinion2(g, S) .
	eq computeOpinion2(g, S) = 2.0 * ( float(getPosArg2(g,S)) / float(size(S)) ) - 1.0 .


	--- with probability p, choose probabilistically a pro argument or con argument from the argument pool
	--- The argument is picked randomly from the PRO ro CON argument set
	op chooseArgument : Float ArgumentPool  -> Argument .
	eq chooseArgument(p, { PRO | CON }) = if sampleBerWithP(p) then randomPick(PRO) else randomPick(CON) fi .

	--- initialize list of memories using the size of the memory, the pro argument probability p, and the argument pool
	op initMemory : Nat Float ArgumentPool -> Memory .
	eq initMemory(0,p,AP) = nil .
	eq initMemory(s(a),p,AP) = chooseArgument(p,AP) initMemory(a,p,AP) .

	--- initialize an Agent using: 
	---   - The id of the agent (id)
	---   - The group it belongs to (g)
	---   -	The size of the memory (a) 
	---   - The pro argument probability (w)
	--- 	- The ArgumentPool (AP)
	op initAgent : Nat Int Nat Float ArgumentPool -> Agent .
	op initAgent2 : Nat Int Memory -> Agent .
	eq initAgent(id, g, a, w, AP) = initAgent2(id, g, initMemory(a,w,AP)) .
	eq initAgent2(id, g, S) = ag(id, g, computeOpinion2(g, S), S) .

endm

--- Definition of view, to be able to construct sets of agents
view Agent from TRIV to AGENTS is
  sort Elt to Agent .
endv

mod NETWORK is 
	pr AGENTS .
	pr SET{Agent} * (sort Set{Agent} to Network, sort NeSet{Agent} to NeNetwork) .


	--- initialize a network. The parameters are:
	---   - The size of the network (N)
	--- 	- The size of the pro argument set (P)
	--- 	- The size of the con argument set (C)
	---   -	The size of the memory (S)
	---   - The pro argument probability (w)
	--- Half of the network will belong to group +1 and the other half to group -1
	vars N P C S n mid : Nat .
	vars w : Float .
	vars AP : ArgumentPool .
	
	op initNetwork : Nat Nat Nat Nat Float -> Network .
	op initNetwork2 : Nat Nat Float ArgumentPool Nat -> Network .
	
	eq initNetwork(N,P,C,S,w) = initNetwork2(N, S, w, initArgumentPool(P,C), N quo 2) .
	
	eq initNetwork2(s(n),S,w,AP,mid) = if s(n) <= mid 
																		 then initAgent(s(n),1,S,w,AP) , initNetwork2(n,S,w,AP,mid)
																		 else initAgent(s(n),-1,S,w,AP) , initNetwork2(n,S,w,AP,mid)
																		 fi .
	eq initNetwork2(0,S,w,AP,mid) = (empty).Network .		
	
endm 